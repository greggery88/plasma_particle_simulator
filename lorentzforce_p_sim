import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from itertools import count
import logging

log = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


def main():
    fig = plt.figure()
    ax = fig.add_subplot(projection="3d")
    # universal constance.
    e = -1.602 * 10**-19
    k = 8.99 * 10**9
    c = 3 * 10**8
    # fields
    ef = np.array([0, 0, 0])
    bf = np.array([0, 0, 10**11])

    # particle dictionary
    pd = {
        "proton": {"m": 1.67 * 10**-27, "Q": -e, "c": "r", "view": 1},
        "electron": {"m": 9.11 * 10**-31, "Q": e, "c": "b", "view": 1},
    }

    class Particle:

        def __init__(self, p_type):
            # particle scaler s
            self.q = p_type["Q"]
            self.m = p_type["m"]
            self.c = p_type["c"]
            self.alpha = np.random.uniform(0.6, 0.9)

            # particle previous positions
            self.xs = []
            self.ys = []
            self.zs = []

            # particle vectors
            self.pos = np.random.uniform(-1, 1, size=3)
            self.velo = np.array([1, 0, 0])
            self.accel = np.array([0, 0, 0])

        def calc_pos(self, t, ps, es):
            debye_length = 10
            f_tot = np.zeros(3)
            # magnetic fields
            vxb = np.cross(self.velo, bf)
            log.info(vxb)

            l_vxb = np.sqrt(vxb[0] ** 2 + vxb[1] ** 2 + vxb[2] ** 2)

            log.info(vxb / l_vxb)
            ff = (e * self.m * self.velo) / (c * self.q)

            log.info(ff)
            f_tot = ff + f_tot

            # internal electric fields
            for p in ps:
                if p != self:
                    displacement = p.pos - self.pos
                    distance = np.sqrt(
                        displacement[0] ** 2
                        + displacement[1] ** 2
                        + displacement[2] ** 2
                    )
                    if distance < debye_length:
                        f = -(
                            1
                            / 2
                            * ((k * self.q * p.q) / (distance**2))
                            * displacement
                            / distance
                        )
                        f_tot = f + f_tot
            for p in es:
                if p != self:
                    displacement = p.pos - self.pos
                    distance = np.sqrt(
                        displacement[0] ** 2
                        + displacement[1] ** 2
                        + displacement[2] ** 2
                    )
                    if distance < debye_length:
                        f = -(
                            1
                            / 2
                            * ((k * self.q * p.q) / (distance**2))
                            * displacement
                            / distance
                        )
                        f_tot = f + f_tot
            self.accel = f_tot / self.m
            self.velo = self.velo + self.accel * t
            print(self.velo)
            self.pos = self.pos + 1 / 2 * self.accel * t**2
            self.velo = self.velo + self.accel * t
            self.xs.append(self.pos[0])
            self.ys.append(self.pos[1])
            self.zs.append(self.pos[2])

        def draw(self):
            plt.plot(self.xs, self.ys, self.zs, c=self.c, alpha=(self.alpha - 0.59))
            plt.plot(
                self.pos[0],
                self.pos[1],
                self.pos[2],
                c=self.c,
                alpha=self.alpha,
                marker=".",
            )

    particles_p = [Particle(pd["proton"]) for _ in range(0)]
    particles_e = [Particle(pd["electron"]) for _ in range(1)]

    def animate_particle(t):
        for particle in particles_p:
            particle.calc_pos(t, particles_p, particles_e)
        for particle in particles_e:
            particle.calc_pos(t, particles_p, particles_e)

        plt.cla()
        for particle in particles_p:
            particle.draw()
        for particle in particles_e:
            particle.draw()

    def on_close_event(event):  # close function
        print(event)
        quit()

    # animation function
    # noinspection PyUnusedLocal,PyTypeChecker
    anim = FuncAnimation(plt.gcf(), animate_particle, frames=100, repeat=False)
    fig.canvas.mpl_connect("close_event", on_close_event)

    # print graphic
    plt.show()


if __name__ == "__main__":
    main()
